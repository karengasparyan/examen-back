let validate,HttpError,md5,fs,uuid,Promise,path,jwt,_;_264‍.x([["default",()=>_264‍.o]]);_264‍.w("../services/validate",[["default",["validate"],function(v){validate=v}]]);_264‍.w("http-errors",[["default",["HttpError"],function(v){HttpError=v}]]);_264‍.w("md5",[["default",["md5"],function(v){md5=v}]]);_264‍.w("fs",[["default",["fs"],function(v){fs=v}]]);_264‍.w("uuid",[["v4",["uuid"],function(v){uuid=v}]]);_264‍.w("bluebird",[["default",["Promise"],function(v){Promise=v}]]);_264‍.w("path",[["default",["path"],function(v){path=v}]]);_264‍.w("jsonwebtoken",[["default",["jwt"],function(v){jwt=v}]]);_264‍.w("lodash",[["default",["_"],function(v){_=v}]]);

const {users} = require("../models").models;








class UsersController {

    static signUp = async (req, res, next) => {
        try {
            await validate(req.body, {
                email: 'required|email',
                password: 'required|string',
                repeatPassword: 'required|string',
                first_name: 'required|string',
                last_name: 'required|string',
                age: 'required|numeric|string',
                phone: 'required|string',
            });

            const {email, password, repeatPassword, first_name, last_name, age, phone} = req.body;
            const {files} = req;

            if (password !== repeatPassword) {
                throw HttpError(422, 'invalid repeat password');
            }

            const user = await users.findOne({email});

            if (user) {
                throw HttpError(402, 'this email is busy');
            }

            if (_.isEmpty(files)) {
                throw HttpError(402, 'Image is required');
            }

            const allowTypes = {
                'image/jpeg': '.jpg',
                'image/gif': '.gif',
                'image/png': '.png',
            };

            files.forEach(file => {
                const {mimetype} = file;
                if (!allowTypes[mimetype]) {
                    throw HttpError(422, 'invalid file type');
                }
            });

            const uniqId = uuid();

            const direction = await path.join(__dirname, `../public/userImage/folder_${uniqId}`);
            if (!fs.existsSync(direction)) {
                fs.mkdirSync(direction, {recursive: true});
            }

            const CreatePictures = [];

            await Promise.map(files, async (file) => {
                const ext = allowTypes[file.mimetype];
                const fileName = `image_${uuid()}${ext}`;
                fs.writeFileSync(path.join(direction, fileName), file.buffer);
                CreatePictures.push(fileName);
            });

            const newUser = await users.create({
                email,
                password: md5(password, '++'),
                first_name,
                last_name,
                age,
                phone,
                picture: CreatePictures
            });

            const directionRename = await path.join(__dirname, `../public/userImage/folder_${newUser.id}`);

            fs.renameSync(direction, directionRename)

            res.json({
                status: 'ok',
                user: newUser,
            });
        } catch (e) {
            _264‍.g.console.log(e)
            next(e);
        }
    };

    static uploadImage = async (req, res, next) => {
        try {
            await validate(req.body, {
                userId: 'required|string',
            });

            const {files} = req;
            const {userId} = req.body;

            const user = await users.findOne({_id: userId});

            if (!user) {
                throw HttpError(404);
            }

            const allowTypes = {
                'image/jpeg': '.jpg',
                'image/gif': '.gif',
                'image/png': '.png',
            };

            files.forEach(file => {
                const {mimetype} = file;
                if (!allowTypes[mimetype]) {
                    throw HttpError(422, 'invalid file type');
                }
            });

            const direction = await path.join(__dirname, `../public/userImage/${userId}`);
            if (!fs.existsSync(direction)) {
                fs.mkdirSync(direction, {recursive: true});
            }

            const CreatePictures = [];

            await Promise.map(files, async (file) => {
                const ext = allowTypes[file.mimetype];
                const fileName = `image_${uuid()}${ext}`;
                fs.writeFileSync(path.join(direction, fileName), file.buffer);
                CreatePictures.push(fileName);
            });

            await users.updateOne({id: user._id, picture: CreatePictures});

            res.json({
                status: 'ok',
            });
        } catch (e) {

            next(e);
        }
    };


    static signIn = async (req, res, next) => {
        try {
            await validate(req.body, {
                email: 'required|string',
                password: 'required|string',
            });

            const {JWT_SECRET} = process.env;

            const {email, password} = req.body;

            const user = await users.findOne({email, password: md5(password, '++')});

            if (!user) {
                throw HttpError(422, 'invalid username or password');
            }

            const token = jwt.sign({userId: user._id}, JWT_SECRET);

           res.json({
                status: 'ok',
                user,
                token,
            });
        } catch (e) {
            next(e);
        }
    };

}

_264‍.d(UsersController);
