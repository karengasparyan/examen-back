let validate,HttpError,_,uuid,path,fs,Promise,md5,Utils;_5a7‍.x([["default",()=>_5a7‍.o]]);_5a7‍.w("../services/validate",[["default",["validate"],function(v){validate=v}]]);_5a7‍.w("http-errors",[["default",["HttpError"],function(v){HttpError=v}]]);_5a7‍.w("lodash",[["default",["_"],function(v){_=v}]]);_5a7‍.w("uuid",[["v4",["uuid"],function(v){uuid=v}]]);_5a7‍.w("path",[["default",["path"],function(v){path=v}]]);_5a7‍.w("fs",[["default",["fs"],function(v){fs=v}]]);_5a7‍.w("bluebird",[["default",["Promise"],function(v){Promise=v}]]);_5a7‍.w("md5",[["default",["md5"],function(v){md5=v}]]);_5a7‍.w("../Utils/Utils",[["default",["Utils"],function(v){Utils=v}]]);








const  {users, events} = require( "../models").models;
// import users from '../models/users';
// import events from '../models/events';

class EventsController {

  static getMyAllEvents = async (req, res, next) => {
    try {
      await validate(req.body, {
        userId: 'required|string',
        page: 'numeric',
      });

      const { userId, query = {}, page = 1, } = req.body;

      _5a7‍.g.console.log(req.body)
      _5a7‍.g.console.log(req.userId)
      _5a7‍.g.console.log(req.page)
      _5a7‍.g.console.log(req.query)

      let limit = 20;
      const offset = (page - 1) * limit;

      const user = users.find({ _id: userId});

      if (!user) {
        throw HttpError(404);
      }

     const pagesCount = events.count();

      const myEvents = await events.find({userId, ...query}).skip(offset).limit(limit).populate('userId');

      await res.json({
        status: 'ok',
        myEvents,
        myEventPagesCount: Math.ceil(pagesCount.length / limit)
      });
    } catch (e) {

      next(e);
    }
  };

  static getAllEvents = async (req, res, next) => {
    try {
      await validate(req.body, {
        page: 'numeric',
      });

      const { query = {}, page = 1, } = req.body;

      let limit = 20;
      const offset = (page - 1) * limit;

     const pagesCount = events.count();

      const allEvents = await events.find({ ...query }).skip(offset).limit(limit);

      await res.json({
        status: 'ok',
        allEvents,
        allEventPagesCount: Math.ceil(pagesCount.length / limit)
      });
    } catch (e) {
      next(e);
    }
  };
 static createEvent = async (req, res, next) => {
    try {
      await validate(req.body, {
        userId: 'required|string',
        title: 'required|string',
        description: 'required|string',
        limit: 'required|string',
        status: 'required',
      });

      const { userId, title, description, limit, status } = req.body;
      const {files} = req;

      const user = await users.findById(userId);

      if (!user) {
        throw HttpError(404);
      }

      if (_.isEmpty(files)) {
        throw HttpError(402, 'Image is required');
      }

      const allowTypes = {
        'image/jpeg': '.jpg',
        'image/gif': '.gif',
        'image/png': '.png',
      };

      files.forEach(file => {
        const {mimetype} = file;
        if (!allowTypes[mimetype]) {
          throw HttpError(422, 'invalid file type');
        }
      });

      const uniqId = uuid();

      const direction = path.join(__dirname, `../public/eventImage/folder_${uniqId}`);
      if (!fs.existsSync(direction)) {
        fs.mkdirSync(direction, {recursive: true});
      }

      const createImage = [];

      await Promise.map(files, async (file) => {
        const ext = allowTypes[file.mimetype];
        const fileName = `image_${uuid()}${ext}`;
        fs.writeFileSync(path.join(direction, fileName), file.buffer);
        createImage.push(fileName);
      });

      const newEvent = await events.create({
        userId,
        title,
        description,
        limit,
        status,
        image: createImage,
      });

      const directionRename = path.join(__dirname, `../public/eventImage/folder_${newEvent.id}`);

      fs.renameSync(direction, directionRename);

      res.json({
        status: 'ok',
        event: newEvent,
      });
    } catch (e) {

      next(e);
    }
  };

  static updateEvent = async (req, res, next) => {
    try {
      await validate(req.body, {
        userId: 'required|string',
        eventId: 'required|string',
        title: 'required|string',
        description: 'required|string',
        limit: 'required|string',
        status: 'required',
        deleteImages: 'array',
      });

      const { userId, eventId, title, description, limit, status, deleteImages } = req.body;
      const {files} = req;

      _5a7‍.g.console.log(title)

      const direction = await path.join(__dirname, `../public/eventImage/folder_${eventId}`);

      const user = await users.findById(userId);

      if (!user) {
        throw HttpError(404, 'invalid user');
      }

      const images = await events.findById(eventId);
      let updateImages = []

      if (!_.isEmpty(deleteImages) && images){
        Utils.deleteImages(images, deleteImages, direction)
      }

      const allowTypes = {
        'image/jpeg': '.jpg',
        'image/gif': '.gif',
        'image/png': '.png',
      };

      files.forEach(file => {
        const {mimetype} = file;
        if (!allowTypes[mimetype]) {
          throw HttpError(422, 'invalid file type');
        }
      });

      const createImage = [];

      await Promise.map(files, async (file) => {
        const ext = allowTypes[file.mimetype];
        const fileName = `image_${uuid()}${ext}`;
        fs.writeFileSync(path.join(direction, fileName), file.buffer);
        createImage.push(fileName);
      });

      const newEvent = await events.updateOne({eventId}, {
        title,
        description,
        limit,
        status,
        image: !_.isEmpty(createImage) ? [...createImage, ...updateImages] : [...updateImages]
       }
      );

      res.json({
        status: 'ok',
        event: newEvent,
      });
    } catch (e) {
      _5a7‍.g.console.log(e)
      next(e);
    }
  };

  static deleteEvent = async (req, res, next) => {
    try {

      await validate(req.body, {
        eventId: 'required|string',
        userId: 'required|string',
      });

      const { userId, eventId } = req.body;

      const user = await users.findById(userId);

      const event = await events.findById(eventId);

      if (!user) {
        throw HttpError(422, 'invalid user');
      }

      if (!event) {
        throw HttpError(422, 'invalid event');
      }

      await events.remove({_id: eventId});

      await res.json({
        status: 'ok',
      });
    } catch (e) {

      next(e);
    }
  };

  static singleEvent = async (req, res, next) => {
    try {

      await validate(req.body, {
        eventId: 'required|string',
      });

      const { eventId } = req.body;

      const singleEvent = await events.findById(eventId);

      if (!singleEvent) {
        throw HttpError(422, 'invalid event');
      }

      await res.json({
        status: 'ok',
        singleEvent,
      });
    } catch (e) {

      next(e);
    }
  };

}

_5a7‍.d(EventsController);
